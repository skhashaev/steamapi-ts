// generate-api-types.ts

import * as fs from 'fs';
import * as path from 'path';
type ApiDefinition = typeof import('./api-definition.json');

export interface Parameter {
  name: string;
  type: string;
  optional: boolean;
  description: string | undefined;
}
// --- CONFIGURATION ---
const DEFINITION_PATH = path.join(process.cwd(), 'src/api-definition.json');
const OUTPUT_PATH = path.join(process.cwd(), 'src/generated.ts');
// --- END CONFIGURATION ---

// Helper to convert API 'type' string to TypeScript type
const toTsType = (apiType: string): string => {
  switch (apiType.toLowerCase()) {
    case 'string':
      return 'string';
    case 'number':
      return 'number';
    case 'bool':
      return 'boolean';

    case 'uint64':
    case 'uint32':
      return 'number';
    default:
      return 'any';
  }
};

// Main function to generate the types file
function generateApiTypes() {
  console.log(`Reading API definition from: ${DEFINITION_PATH}`);

  if (!fs.existsSync(DEFINITION_PATH)) {
    console.error(`❌ Error: API definition file not found at ${DEFINITION_PATH}`);
    process.exit(1);
  }

  const rawData = fs.readFileSync(DEFINITION_PATH, 'utf-8');
  const apiDef: ApiDefinition = JSON.parse(rawData);

  const interfaceNames = new Set<string>();
  const paramTypeDefinitions = new Map<string, string>();
  const methodParamMapping = new Map<string, string>();
  const methodNamesPerInterface = new Map<string, string[]>();

  // --- 1. Iterate and Generate Parameter Types ---
  for (const apiInterface of apiDef.apilist.interfaces) {
    const interfaceName = apiInterface.name;
    interfaceNames.add(interfaceName);

    const methodNames: string[] = [];

    for (const method of apiInterface.methods) {
      const methodName = method.name;
      methodNames.push(`'${methodName}'`);

      const paramsTypeName = `${methodName}Params`;
      const paramsProps: string[] = [];
      const methodParameters = Array.isArray(method.parameters) ? method.parameters : [];

      for (const param of methodParameters) {
        const tsType = toTsType(param.type);
        const optionalMark = param.optional ? '?' : '';
        const finalType = param.optional ? `${tsType} | undefined` : tsType;
        const paramName = /^[A-Za-z_][A-Za-z0-9_]*$/.test(param.name)
          ? param.name
          : `'${param.name}'`;

        paramsProps.push(`${paramName}${optionalMark}: ${finalType};`);
      }

      const paramsTypeBody =
        paramsProps.length > 0 ? `{\n${paramsProps.join('\n')}\n}` : 'Record<string, never>';

      paramTypeDefinitions.set(
        paramsTypeName,
        `export type ${paramsTypeName} = ${paramsTypeBody};`,
      );

      methodParamMapping.set(methodName, `  '${methodName}': ${paramsTypeName};`);
    }

    methodNamesPerInterface.set(interfaceName, methodNames);
  }

  // --- 2. Assemble Generated Content ---
  let generatedContent = '/* eslint-disable */\n';
  generatedContent += '// Generated by generate-api-types.ts. DO NOT EDIT MANUALLY.\n\n';

  // A. Add all generated parameter types
  generatedContent += `${Array.from(paramTypeDefinitions.values()).join('\n\n')}\n\n`;

  // B. Generate Interface Names Union
  const interfaceUnion = Array.from(interfaceNames)
    .map(n => `'${n}'`)
    .join(' | ');
  generatedContent += `export type InterfaceName = ${interfaceUnion || 'never'};\n\n`;

  // C. Generate Conditional Method Names Union
  generatedContent += 'export type MethodName<I extends InterfaceName> = \n';
  apiDef.apilist.interfaces.forEach(apiInterface => {
    const methods = methodNamesPerInterface.get(apiInterface.name) ?? [];
    const methodsUnion = methods.length > 0 ? methods.join(' | ') : 'never';

    generatedContent += `  I extends '${apiInterface.name}' ? ${methodsUnion || 'never'} :\n`;
  });
  generatedContent += '  never;\n\n';

  // D. Generate the parameter mapping utility (crucial for MyClientType)
  generatedContent +=
    '/** Utility type to map method names to their generated parameter types */\n';
  generatedContent += 'export type MethodParamsMap = {\n';
  generatedContent += `${Array.from(methodParamMapping.values()).join('\n')}\n};\n`;

  // --- 3. Write Output ---
  fs.writeFileSync(OUTPUT_PATH, generatedContent);
  console.log(`✅ Successfully generated literal types at ${OUTPUT_PATH}`);
}
generateApiTypes();
