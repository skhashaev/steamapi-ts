// generate-api-types.ts

import * as fs from 'fs';
import * as path from 'path';
import { API } from './index.js';

type ApiDefinition = API['default'];

export interface Parameter {
    name: string;
    type: string;
    optional: boolean;
    description: string | undefined;
  }
// --- CONFIGURATION ---
const DEFINITION_PATH = path.join(process.cwd(), 'src/api-definition.json');
const OUTPUT_PATH = path.join(process.cwd(), 'src/generated.ts');
// --- END CONFIGURATION ---

// Helper to convert API 'type' string to TypeScript type
const toTsType = (apiType: string): string => {
    switch (apiType.toLowerCase()) {
        case 'string': return 'string';
        case 'number': return 'number';
        case 'boolean': return 'boolean';
        default: return 'any';
    }
};

// Main function to generate the types file
function generateApiTypes() {
    console.log(`Reading API definition from: ${DEFINITION_PATH}`);

    if (!fs.existsSync(DEFINITION_PATH)) {
        console.error(`❌ Error: API definition file not found at ${DEFINITION_PATH}`);
        process.exit(1);
    }

    const rawData = fs.readFileSync(DEFINITION_PATH, 'utf-8');
    const apiDef: ApiDefinition = JSON.parse(rawData);
    
    const interfaceNames: string[] = [];
    const paramTypeDefinitions: string[] = [];
    const paramMapping: string[] = [];

    // --- 1. Iterate and Generate Parameter Types ---
    for (const apiInterface of apiDef.apilist.interfaces) {
        const interfaceName = apiInterface.name;
        interfaceNames.push(interfaceName);

        for (const method of apiInterface.methods) {
            const methodName = method.name;
            const paramsTypeName = `${methodName}Params`;
            const paramsProps = new Set<string>();

            if (method.parameters.length > 0) {
                for (const param of method.parameters as Parameter[]) {
                    const tsType = toTsType(param.type);
                    const optionalMark = param.optional ? '?' : '';
                    const finalType = param.optional ? `${tsType} | undefined` : tsType;
                    
                    paramsProps.add(`${param.name}${optionalMark}: ${finalType};`);
                }
            }

            // Generate the type alias definition string
            paramTypeDefinitions.push(`export type ${paramsTypeName} = {\n${Array.from(paramsProps).join('\n')}\n};`);
            
            // Add to the mapping for the MethodParamsMap utility
            paramMapping.push(`  '${methodName}': ${paramsTypeName};`);
    }

    // --- 2. Assemble Generated Content ---
    let generatedContent = '/* eslint-disable */\n';
    generatedContent += '// Generated by generate-api-types.ts. DO NOT EDIT MANUALLY.\n\n';

    // A. Add all generated parameter types
    generatedContent += paramTypeDefinitions.join('\n\n') + '\n\n';

    // B. Generate Interface Names Union
    const interfaceUnion = interfaceNames.map(n => `'${n}'`).join(' | ');
    generatedContent += `export type InterfaceName = ${interfaceUnion || 'never'};\n\n`;

    // C. Generate Conditional Method Names Union
    generatedContent += 'export type MethodName<I extends InterfaceName> = \n';
    apiDef.apilist.interfaces.forEach((apiInterface, index) => {
        const methodsUnion = apiInterface.methods.map(m => `'${m.name}'`).join(' | ');
        const endChar = (index === apiDef.apilist.interfaces.length - 1) ? ';' : ':';
        
        generatedContent += `  I extends '${apiInterface.name}' ? ${methodsUnion || 'never'} ${endChar}\n`;
    });
    generatedContent += '\n';

    // D. Generate the parameter mapping utility (crucial for MyClientType)
    generatedContent += '/** Utility type to map method names to their generated parameter types */\n';
    generatedContent += 'export type MethodParamsMap = {\n';
    generatedContent += paramMapping.join('\n') + '\n};\n';


    // --- 3. Write Output ---
    fs.writeFileSync(OUTPUT_PATH, generatedContent);
    console.log(`✅ Successfully generated literal types at ${OUTPUT_PATH}`);
}
}
generateApiTypes();