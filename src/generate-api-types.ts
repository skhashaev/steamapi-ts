// generate-api-types.ts

import * as fs from 'fs';
import * as path from 'path';
type ApiDefinition = typeof import('./api-definition.json');

export interface Parameter {
  name: string;
  type: string;
  optional: boolean;
  description: string | undefined;
}

// --- CONFIGURATION ---
const DEFINITION_PATH = path.join(process.cwd(), 'src/api-definition.json');
const OUTPUT_PATH = path.join(process.cwd(), 'src/generated.ts');
// --- END CONFIGURATION ---

// Helper to convert API 'type' string to TypeScript type
const toTsType = (apiType: string): string => {
  switch (apiType.toLowerCase()) {
    case 'string':
      return 'string';
    case 'number':
      return 'number';
    case 'bool':
      return 'boolean';

    case 'uint64':
    case 'uint32':
      return 'number';
    default:
      return 'any';
  }
};

const indentLines = (lines: string[], indentLevel = 2): string =>
  lines.map(line => `${' '.repeat(indentLevel)}${line}`).join('\n');

// Main function to generate the types file
function generateApiTypes() {
  console.log(`üìÑ Reading API definition from: ${DEFINITION_PATH}`);

  if (!fs.existsSync(DEFINITION_PATH)) {
    console.error(`‚ùå Error: API definition file not found at ${DEFINITION_PATH}`);
    process.exit(1);
  }

  const rawData = fs.readFileSync(DEFINITION_PATH, 'utf-8');
  const apiDef: ApiDefinition = JSON.parse(rawData);

  const interfaceNames = new Set<string>();
  const paramTypeDefinitions = new Map<string, string>();
  const methodParamMapping = new Map<string, string>();
  const methodInfoMapping = new Map<string, Map<string, string>>();
  const methodNamesPerInterface = new Map<string, string[]>();

  // --- 1. Iterate and Generate Parameter Types ---
  for (const apiInterface of apiDef.apilist.interfaces) {
    const interfaceName = apiInterface.name;
    interfaceNames.add(interfaceName);

    const methodNames: string[] = [];

    for (const method of apiInterface.methods) {
      const methodName = method.name;
      const methodVersion = Number(method.version ?? 1);
      const methodIdentifier = `${methodName}_v${methodVersion}`;
      methodNames.push(`'${methodIdentifier}'`);

      const paramsTypeName = `${methodName}V${methodVersion}Params`;
      const paramsProps: string[] = [];
      const methodParameters = Array.isArray(method.parameters) ? method.parameters : [];
      const httpMethod = (method.httpmethod ?? 'GET').toUpperCase();

      for (const param of methodParameters) {
        if (param.name === 'key') continue;
        const tsType = toTsType(param.type);
        const optionalMark = param.optional ? '?' : '';
        const finalType = param.optional ? `${tsType} | undefined` : tsType;
        const paramName = /^[A-Za-z_][A-Za-z0-9_]*$/.test(param.name)
          ? param.name
          : `'${param.name}'`;

        paramsProps.push(`${paramName}${optionalMark}: ${finalType};`);
      }

      const paramsTypeBody =
        paramsProps.length > 0 ? `{\n${indentLines(paramsProps)}\n}` : 'Record<string, never>';

      paramTypeDefinitions.set(
        paramsTypeName,
        `export type ${paramsTypeName} = ${paramsTypeBody};`,
      );

      methodParamMapping.set(methodIdentifier, `  '${methodIdentifier}': ${paramsTypeName};`);
      if (!methodInfoMapping.has(interfaceName)) {
        methodInfoMapping.set(interfaceName, new Map<string, string>());
      }

      methodInfoMapping
        .get(interfaceName)!
        .set(
          methodIdentifier,
          `    '${methodIdentifier}': {` +
            ` interface: '${interfaceName}',` +
            ` name: '${methodName}',` +
            ` version: ${methodVersion},` +
            ` httpMethod: '${httpMethod}'` +
            ' },',
        );
    }

    methodNamesPerInterface.set(interfaceName, methodNames);
  }

  // --- 2. Assemble Generated Content ---
  let generatedContent = '/* eslint-disable */\n';
  generatedContent += '// Generated by generate-api-types.ts. DO NOT EDIT MANUALLY.\n\n';

  // A. Add all generated parameter types
  generatedContent += `${Array.from(paramTypeDefinitions.values()).join('\n\n')}\n\n`;

  // B. Generate Interface Names Union
  const interfaceUnion = Array.from(interfaceNames)
    .map(n => `'${n}'`)
    .join(' | ');

  generatedContent += `export type InterfaceName = ${interfaceUnion || 'never'};\n\n`;

  // C. Generate Conditional Method Names Union
  generatedContent += 'export type MethodName<I extends InterfaceName> = \n';

  apiDef.apilist.interfaces.forEach(apiInterface => {
    const methods = methodNamesPerInterface.get(apiInterface.name) ?? [];
    const methodsUnion = methods.length > 0 ? methods.join(' | ') : 'never';

    generatedContent += `  I extends '${apiInterface.name}' ? ${methodsUnion || 'never'} :\n`;
  });

  generatedContent += '  never;\n\n';

  // D. Generate the parameter mapping utility (crucial for MyClientType)
  generatedContent +=
    '/** Utility type to map method names to their generated parameter types */\n';
  generatedContent += 'export type MethodParamsMap = {\n';
  generatedContent += `${Array.from(methodParamMapping.values()).join('\n')}\n};\n`;

  generatedContent += '\n';
  generatedContent += '/** Metadata for each generated method identifier */\n';
  generatedContent += 'export const methodInfo = {\n';
  generatedContent += Array.from(methodInfoMapping.entries())
    .map(([iface, methods]) => {
      const methodEntries = Array.from(methods.values()).join('\n');
      return `  '${iface}': {\n${methodEntries}\n  },`;
    })
    .join('\n');
  generatedContent += '\n} as const;\n';
  generatedContent += 'export type MethodInfoMap = typeof methodInfo;\n';

  // --- 3. Write Output ---
  fs.writeFileSync(OUTPUT_PATH, generatedContent);
  console.log(`‚úÖ Successfully generated literal types at ${OUTPUT_PATH}`);
}
generateApiTypes();
